# 元素的水平竖直居中

以下例子的共同代码：

- 相同布局

```html
<div class="parent">
  <div class="child">Hello, world</div>
</div>
```

- 基本样式

```css
:root {
  -webkit-font-smoothing: antialiased;
}

.parent {
  background: #f06292;
  height: 400px;
}

.child {
  background: #2196f3;
  color: white;
  font-weight: bold;
  font-size: 30px;
  width: 200px;
  height: 100px;
  line-height: 100px;
  text-align: center;
}
```

## 1. 基于绝对定位

原理：元素(B)绝对定位于要居中的祖先元素(A)，然后可以使用left、top，将B的左上定点移动到A的中心点处；最后通过某种方式偏移、使得二者中心点重合。

1. 首先设置绝对定位：这里需要让child居中于parent。

```css
.parent {
  position: relative; /* 这句是必要的，使parent成为child的包含块(containing block) */
}

.child {
  position: absolute;
}
```

2. 大偏移：使用50%的top和left，将child向下、向右偏移50%(相对于包含块)的大小。此时child的左上顶点到达parent的中心点：

```css
.child {
  top: 50%;
  left: 50%;
}
```

3. 最后进行小偏移：将child再往左上挪(使用margin)，使其中心点与parent中心点重合。  
而这里又有几种小思路：

- 偏移固定长度：
```css
.child {
  margin-top: -50px; /* 绝对值等于child高度的一半 */
  margin-left: -100px; /* 绝对值等于child宽度的一半 */
}
```
所以该方法的使用场景有限：child的宽高必须都为定值。

- 使用calc，将步骤2、3合成一步：
```css
.child {
  top: calc(50% - 50px);
  left: calc(50% - 100px);
}
```
其实跟上面的相同。只是在写法上更简单了，但需要考虑calc的兼容性。

- 使用translate百分比：
```css
.child {
  transform: translate(-50%, -50%);
}
```
translate的百分比相对于自身的宽高，所以可以在child宽高未知/不固定的场景下使用。

- 使用margin: auto（另，2、3合成一步）：

原理：使用值为0的left、right、top、bottom以将child的外部尺寸(margin box)占满包含块。这时候，child的width、height如果没有指定(可以认为是默认情况)，则占满，即margin为0；但因为child设置了宽高，再使用 margin:auto 就可以使 margin 平等地占据剩下的宽度(并且是竖直、水平两个方向都平分)。这个方法参考于张鑫旭前辈的《CSS世界》。

```css
.child {
  /* 使child的外部尺寸(margin box)占满包含块 */
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  /* 居中 */
  margin: auto;
}
```

关于这个，再具体的解释可以看[CSS规范](https://www.w3.org/TR/CSS2/visudet.html#abs-non-replaced-width)。关键句子是：

> If none of the three('left', 'width', and 'right') is 'auto': If both 'margin-left' and 'margin-right' are 'auto', solve the equation under the extra constraint that the two margins get equal values


## 2. Flexbox布局

该方法很“省力”，不必考虑是否容器/元素是定宽/相对宽度/无声明宽度。只需要将父元素设置为flexbox，再使用一些flex相关属性，很容易让所有子元素居中了：
```css
.parent {
  /* 设置内部结构(流)为flex */
  display: flex;
  flex-direction: row;
  /* 副轴(这里是y)居中 */
  align-items: center;
  /* 主轴(这里是x)居中 */
  justify-content: center;
}
```
兼容性是可能的缺点，但我认为它是未来多端主流的布局方式。

## 写在最后

在【基于绝对定位】的方案中，如果使用margin-bottom和margin-right：
```css
.child {
  margin-bottom: 50px;
  margin-right: 100px;
}
```
是不能达到期望效果的：child的位置不变，却会增大外部尺寸。为什么呢？可以参考：[CSS2规范：绝对定位非替换元素的width、margin的计算](https://www.w3.org/TR/CSS2/visudet.html#abs-non-replaced-width)。这里我粗略地解释一下：

盒子模型水平方向的约束等式为：

> 'left' + 'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' + 'right' = width of containing block

本场景属于：

> Otherwise, set 'auto' values for 'margin-left' and 'margin-right' to 0

> 'right' is 'auto', 'left' and 'width' are not 'auto', then solve for 'right' 

规范中的等式，在本场景中可以简化为：

> left + margin-left + width + margin-right + right = 包含块内容区宽度

假如parent内容区宽度为 800px ，则已知的有：
- left：800px * 50% = 400px
- width: 200px

所以：
- 当指定 margin-left 为 -100px 时， margin-right 因为是 auto 所以变为 0 ，算得 right 为 300px 。这时候，因为 left + margin-left 等于 300px ，所以在视觉上，child 距离左边 parent 有 300px，右边距离 parent 为 margin-right + right = 0 + 300px = 300px，所以是居中的。
- 当指定 margin-right 为 100px 时， 最终算得：left + margin-left = 400px + 0 = 400px，以及：margin-right + right = 100px + 100px = 200px，而 400px 就是大偏移之后的位置，即小偏移根本没有用，即位置没有变。
